//! ## 修复栅栏
//!
//! 这个问题，也被归属到了贪心算法内，为什么会被归纳到了贪心算法内呢，首先问题是要求最小的切割代价，我们知道这样的一个事实，如果一个长度为6的木板切割的代价是6，如果让一个木板正好的
//! 被切割为4，2 那么这样的话代价就是最小的，如果我们需要一个长度为4
//! 的木板，但是我们又需要一个长度为3的木板，那么对于一个长度为6的木板，如果先切割出来一个长度为5的木板，在切割其他变成长度为3
//! 木板就有点复杂了。
//!
//! 所以这个问题的贪心依据，就是尽可能多的切割一次能生成两个我们想要的木板长度。
//! 当然还有一个依据就是，切割之前的木板长度确实是切割之后的木板长度。

#[allow(dead_code)]
pub fn fence_repair_greedy() -> i32 {
    0
}
